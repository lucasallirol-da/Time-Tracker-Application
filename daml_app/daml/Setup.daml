module Setup where
import Daml.Script
import DA.Time
import DA.Date
import Timetracker
import TimeSummary

defaultParticipant : Optional ParticipantName
defaultParticipant = None
-- | Create a public party, then create three test users.

setup : Script ([ContractId Timetracker])
setup = do
  alice <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")
  aliceId <- validateUserId "alice"
  createUser (User aliceId (Some alice)) [CanActAs alice]

  newApp <- allocateParty "New App"
  support <- allocateParty "Support"
  ux <- allocateParty "UX design"

  
  --TT=TimeTracker
  newAppTTCid <- createTTCertificate alice newApp
  supportTTCid <- createTTCertificate alice support
  uxTTCid <- createTTCertificate alice ux

  -- Stop Tracking new app by exercising contract change
  newAppTTCid <- submit alice do exerciseCmd newAppTTCid StopTracking
  -- Start tracking again the new app project
  newAppTTCid <- createTTCertificate alice newApp
  
  -- contracts <- getContracts alice
  -- totalTime <- getTotalTime newAppTTCid


  return ([newAppTTCid,supportTTCid,uxTTCid])
  



  
  
-- Setup script to create Timetrackers certificates
createTTCertificate : Party -> Party -> Script (ContractId Timetracker)
createTTCertificate user project = do
    -- let defaultTime= seconds 0
    -- Define the Unix epoch time (1970-01-01T00:00:00Z) as default endTimevalue
    let defaultendTime = time (date 1970 Jan 1) 00 00 00
    -- Get the current time
    currentTime <- getTime
    submit user do
      createCmd Timetracker with
        project
        description = "working on this project"
        startTime = currentTime
        endTime =  defaultendTime
        user
        timeIsTracked = True

-- Setup script to create TimeSummary certificates
createTSCertificate : Party -> Optional Party -> [Timetracker] -> Script (RelTime)
createTSCertificate user project timetrackers = do
  totalTime <- getTotalTime timetrackers
  submit user do
    createCmd TimeSummary with
      user
      project
      timetrackers
      totalTime 
  --return totalTime for test purpose
  return totalTime


-- test_setup = script do
  -- timeTrackersList <- setup
  -- temp <- fetchActiveContractsByTemplate Timetracker
  -- Some timeTracker1  <- queryContractId alice timeTrackersList._1
  -- assert(timeTrackersList._1.description == "working on this project")



-- Function to query all contracts for one project or one user
getContracts : Party -> Script [Timetracker]
getContracts party= do 
  contracts <- query @Timetracker party
  -- Previous contract return both contractId and contract, we map to get only the contract part (the c._2) of each element in the contracts list
  pure (map (\c -> c._2) contracts)

getTotalTime : [Timetracker] -> Script RelTime
getTotalTime contracts = script do
  -- sum each contract duration starting from 0 (seconds 0)
  pure (foldl (+) (seconds 0) (map calculateDuration contracts))

-- Function to calculate the duration for a single Timetracker contract
calculateDuration : Timetracker -> RelTime
-- Don't calculate duration if the time is currently tracked (because endTime would be irrelevent)
calculateDuration tracker = if tracker.timeIsTracked
  then seconds 0
  else subTime tracker.endTime tracker.startTime

-- Filter the Timetrackers by period (day,week,year...)
filterTimeTrackers : [Timetracker] -> Time -> Time -> Script [Timetracker]
filterTimeTrackers contracts periodStart periodEnd = script do
  -- remove from the list contracts with end date not included in the period searched
  -- A choice was made to choose only the end date rather than start date or both included in the period
  pure (foldl (\state c -> if c.endTime >= periodStart && c.endTime <= periodEnd then c :: state else state) [] contracts)

-- -- Fetch the contract from Id and return the totalTime (for assert test purpose)
-- fetchTotalTime : ContractId TimeSummary -> Script RelTime
-- fetchTotalTime timeSummaryId = do
--   timeSummary <- fetch timeSummaryId
--   return timeSummary.totalTime



create_summary = script do
  alice <- allocateParty "Alice"
  newApp <- allocateParty "New App"
  support <- allocateParty "Support"
  ux <- allocateParty "UX design"
  setTime (time (date 2024 Apr 5) 14 30 05)

  --TT is short for TimeTracker
  newAppTTCid <- createTTCertificate alice newApp
  supportTTCid <- createTTCertificate alice support
  uxTTCid <- createTTCertificate alice ux

  passTime (hours 10)
  -- Stop Tracking new app by exercising contract change
  newAppTTCid <- submit alice do exerciseCmd newAppTTCid StopTracking

  passTime (days 5)

  supportTTCid <- submit alice do exerciseCmd supportTTCid StopTracking

  passTime (days 30)

  uxTTCid <- submit alice do exerciseCmd uxTTCid StopTracking

  newAppContracts <- getContracts newApp
  supportContracts <- getContracts support
  uxContracts <- getContracts ux


  --Alice is signatory on all contracts so get contracts will query every contract of Timetracker template
  allContracts <- getContracts alice
  allContractsTime <- getTotalTime allContracts

  -- Create TimeSummary for specifics projects
  newAppTotalTime <- createTSCertificate alice (Some newApp) newAppContracts
  supportTotalTime <- createTSCertificate alice (Some support) supportContracts
  uxTotalTime <- createTSCertificate alice (Some ux) uxContracts

  assert(newAppTotalTime> seconds 0)
  assert(supportTotalTime> newAppTotalTime)
  assert(uxTotalTime> supportTotalTime)

  --Create TimeSummary for all projects (That Alice worked on)
  toDateTotalTime <- createTSCertificate alice None allContracts
  assert(toDateTotalTime == newAppTotalTime + supportTotalTime + uxTotalTime)

  --Create TimeSummary for every Project during April (Projects that were finsihed in April)
  allAprilContracts <- filterTimeTrackers allContracts (time (date 2024 Apr 1) 00 00 00) (time (date 2024 Apr 30) 00 00 00)
  allAprilContractsTime <- getTotalTime allAprilContracts
  aprilTotalTime <- createTSCertificate alice None allAprilContracts
  assert(aprilTotalTime == newAppTotalTime + supportTotalTime)



